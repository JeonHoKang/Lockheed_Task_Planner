from asyncio import get_child_watcher
from PyQt5 import QtCore, QtGui, QtWidgets
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
import igraph as ig
from igraph import Graph, EdgeSeq
from tkinter import ttk
import tkinter as tk
import matplotlib.pyplot as plt
import sys
from matplotlib.figure import Figure
import plotly.graph_objects as go
import Lockheed_task_planner 
import anytree
from anytree import AnyNode, PostOrderIter
from anytree.exporter import DictExporter
from anytree import RenderTree  # just for nice printing
from anytree.importer import DictImporter
import numpy as np

_RENDER_CMD = ['dot']
_FORMAT = 'png'
# print(data['children'][0]['children'][0]['children'][0])


def recui(htn):
    if "children" in htn:
        parent = htn['id']
        children = htn["children"]
        child_list = []
        for child in children:
            child_list.append(recui(child))
        return child_list
    else:
        return htn["id"]


    
class HTN_vis(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.n_vertices = 1
        self.edges = []
        self.render_node_to_edges()
        self.g = Graph(self.n_vertices, self.edges)
        self.labels = []
        # self.g.vs['label'] = '0'
        # self.g.vs['name'] = self.labels
        for i in range(self.n_vertices):
            print(i)
            self.g.vs[i]["label"] = f"{i}"
            self.g.vs[i]["name"] = f"{i}: {self.node_ids[i]}"
            self.labels.append(self.g.vs[i]["name"])
        print(self.labels)
        input()
        self.fig = Figure(figsize=(100, 600))
        self.fig.set_size_inches(15, 50)
        self.canvas = FigureCanvas(self.fig)
        self.canvas.setFixedSize(10000, 800)
        self.toolbar = NavigationToolbar(self.canvas, self)
        self.ax = self.fig.add_subplot(111)
        self.plot()     
        self.parent_node = QtWidgets.QLineEdit('Parent')
        self.label = QtWidgets.QLineEdit('label')
        # self.x_input.returnPressed.connect(self.process_input)
        # Add a button to trigger an update
        # self.y_input.returnPressed.connect(self.process_input)
        self.submit_button = QtWidgets.QPushButton("Submit")
        self.submit_button.clicked.connect(self.add_node_gui)
        self.delete_node = QtWidgets.QLineEdit('delete')
        self.delete_submit = QtWidgets.QPushButton("Delete")
        self.delete_submit.clicked.connect(self.del_node_gui)
        self.list_widget = QtWidgets.QListWidget()
        scroll_area = QtWidgets.QScrollArea()
        scroll_area.setWidgetResizable(True)
        list_scroll_area = QtWidgets.QScrollArea()
        list_scroll_area.setWidgetResizable(True)
        list_scroll_area.setWidget(self.list_widget)
        layout0 = QtWidgets.QVBoxLayout()
        layout1 = QtWidgets.QHBoxLayout()
        layout0.addWidget(list_scroll_area)
        self.list_widget.addItems(self.labels)
        # layout1.addWidget(self.canvas)
        scroll_area.setWidget(self.canvas)
        layout1.addWidget(scroll_area)
        
        layout2 = QtWidgets.QVBoxLayout()
        layout2.addWidget(self.toolbar)
        layout2.addWidget(self.parent_node)
        layout2.addWidget(self.label)
        layout2.addWidget(self.submit_button)
        layout3 = QtWidgets.QVBoxLayout()
        layout3.addWidget(self.delete_node)
        layout3.addWidget(self.delete_submit)
        container = QtWidgets.QWidget()
        container.setLayout(layout0)
        container.layout().addLayout(layout1)
        container.layout().addLayout(layout2)
        container.layout().addLayout(layout3)
        # Add the Matplotlib canvas to the PyQt window
        self.setCentralWidget(container)


    def render_node_to_edges(self):
        scheduler = Lockheed_task_planner.HtnMilpScheduler()
        scheduler.set_dir("problem_description/LM2023_problem/")
        scheduler.import_problem("problem_description_LM2023.yaml")
        scheduler.create_task_model()
        htn = scheduler.import_htn()
        self.htn_dict = scheduler.dict
        self.htn_nodes = []
        children = []
        parent = []
        node_recur = recui(self.htn_dict)

        if scheduler.dict is not None:
            task_network = DictImporter().import_(self.htn_dict)
            for node in PostOrderIter(task_network):
                self.htn_nodes.append(node)
                if node.type == "atomic":
                    children.append(node)
                else:
                    parent.append(node)

        def has_deeper_array(arr):
            if isinstance(arr, list):
                for item in arr:
                    if isinstance(item, list):
                        return True
                    elif isinstance(item, (tuple, set, frozenset)):
                        if has_deeper_array(list(item)):
                            return True
            return False
                
        def convert_multi_multilayer_array_to_edges(arr):
            edges = []
            index = 1
            
            def traverse_array(node, parent_node=0):
                nonlocal index
                
                for i in range(len(node) - 1, -1, -1):
                    child_node = node[i]
                    edges.append((parent_node, index))
                    index += 1
                    
                    if isinstance(child_node, list):
                        traverse_array(child_node, index-1)
            
            traverse_array(arr)
            
            return edges
        
        def extract_node_ids(tree, ids):
            # Append the ID of the current node
            ids.append(tree['id'])
            
            # Recursively process the children nodes
            if 'children' in tree:
                for child in tree['children']:
                    extract_node_ids(child, ids)
        self.node_ids = []
        extract_node_ids(self.htn_dict, self.node_ids)
        print(self.node_ids)
        list_tuple_edges = convert_multi_multilayer_array_to_edges(node_recur)
        print(list_tuple_edges)
        input()
        self.edges = list_tuple_edges
        self.n_vertices = len(self.htn_nodes)

        

    def process_input(self):
        # Get the user input and do something with it
        print("theta input:", self.parent_node.text())

    def trace(self, root):
        # builds a set of all nodes and edges in a graph
        nodes, edges = set(), set()

        def build(v):
            if v not in nodes:
                nodes.add(v)
                for child in v._children:
                    edges.add((child, v))
                    build(child)
        build(root)
        return nodes, edges

    def plot(self):
        # self.g = Graph(self.n_vertices, self.edges)
        self.g["title"] = "HTN"
        layout = self.g.layout("rt", root=[0])
        layout.rotate(-180)
        layout.fit_into((20000, 30000))

        # layout.scale(5000)
        ig.plot(
            self.g,
            layout=layout,
            target=self.ax,
            vertex_size=100,
            showlegend=False,
            vertex_color = 'yellow',
            vertex_label_size=9
                            )
        self.canvas.draw()

    def add_node_gui(self):
        self.ax.clear()
        user_input_parent = self.parent_node.text()
        if user_input_parent.isalpha():
            print('string')
            pass
        else:
            user_input_parent = int(user_input_parent)
            if user_input_parent > self.n_vertices-1:
                pass
            self.n_vertices += 1
            print('number of vertices', self.n_vertices)
            # self.edges.append((user_input_parent, self.n_vertices-1))
            # self.labels.append(self.label.text())
            self.g.add_vertices(1)
            self.g.add_edges([(user_input_parent, self.n_vertices-1)])
            self.g.vs[self.n_vertices -
                      1]["label"] = f"{self.n_vertices-1}"
            self.g.vs[self.n_vertices -
                      1]["name"] = f"{self.n_vertices-1}: {self.label.text()}"
            self.labels.append(self.g.vs[self.n_vertices -
                                         1]["name"])
            self.list_widget.clear()
            print(self.labels)
            self.list_widget.addItems(self.labels)
            edge_list = self.g.get_edgelist()
            vertex_list = self.g.vs
            # print the resulting list of dictionaries
            print('vertex: ', list(vertex_list))
            print('edge: ', edge_list)
        self.plot()

    def del_node_gui(self):
        self.ax.clear()
        user_delete = self.delete_node.text()
        if user_delete.isalpha():
            print('string')
            pass
        else:
            user_delete = int(user_delete)
            if user_delete > self.n_vertices-1:
                pass
            # self.g.delete_edges(user_delete)
            self.g.delete_vertices(user_delete)
            edge_list = self.g.get_edgelist()
            vertex_list = self.g.vs
            self.n_vertices -= 1
            # print the resulting list of dictionaries
            print('vertex: ', list(vertex_list))
            print('edge_list: ', edge_list)
            self.labels.pop(user_delete)
            self.list_widget.clear()
            self.list_widget.addItems(self.labels)
        self.plot()


def main():
    app = QtWidgets.QApplication(sys.argv)
    htn = HTN_vis()
    htn.show()
    sys.exit(app.exec_())

    # Digraph_HTN = htn.draw_dot(A)
    # app = QtWidgets.QApplication(sys.argv)
    # window = MainWindow()
    # window.show()
    # sys.exit(app.exec_())


if __name__ == '__main__':
    main()
